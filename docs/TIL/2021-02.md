---
layout: default
title: 2021-02
parent: TIL
nav_order: 1
---

# 2021-02
{: .no_toc }

## contents
{: .no_toc .text-delta }

1. TOC
{:toc}
---

## 2021-02-11

### CI, CD란 무엇인가?

<b>CI는 Continuous Integration 즉, 지속적인 통합</b>이라는 의미이다.
지속적인 통합이란 어플리케이션의 새로운 코드 변경 사항이 정기적으로
빌드 및 테스트 되어 공유 레포지토리에 통합하는 것을 의미한다.

예를 들면?
- 다수의 개발자가 한 팀으로 작업할 경우, 이 공유 레포지토리에 수 많은 커밋들이 쌓인다.
그럴 때마다, 기능별로 빌드/테스트/병함까지 하려면 번거롭기 때문에 자동화된 빌드&테스트는
원천 소스코드의 충돌 등을 방어하는 Benefit을 제공할 수 있다.

- MSA 환경에서 대부분 Agile(소규모 기능 단위로 빠르게 개발 & 적용을 반복하는 개발방법론) 방법론이 적용된다.
기능 추가가 매우 빈번하기 때문에 동작테스트도 중요하다. 이런 상황에서 CI의 적용은 기능 충돌 방지 등의 Benefit을 제공한다.

이러한 CI의 핵심 목표는 버그를 신속하게 찾아 해결하고, 소프트웨어의 품질을 개선하고
새로운 업데이트의 검증 및 릴리즈의 시간을 단축시키는 것에 있다.

<b>CD는 Continuous Delivery & Continuous Depolyment</b> 두 용어 모두의 축약어다.
해석하자면 지속적인 서비스 제공 혹은 지속적인 배포라는 의미를 갖고 있다.

Continuous Delivery는 공유 레포지토리로 자동으로 Release 하는 것, Continuous Deployment는 Production 레벨까지 자동으로 배포하는 것을 의미한다.
정리하자면 CI는 새로운 소스코드의 빌드, 테스트, 병합까지를 의미한다면 CD는 개발자의 변경 사항이 레포지토리를 넘어 고객의 프로덕션 환경까지 릴리즈 되는것을 의미한다.

CI에서 예로 든 MSA와 같은 환경에서 에자일 방법론이 적용될 경우 서비스의 사용자는 최대한 빠른 시간 내에
최신 버전의 Production을 제공 받을 필요가 있다.
이 때, 소프트웨어가 언제든지 신뢰 가능한 수준의 버전을 유지할 수 있도록 서포트 하는 것이 CD라고 할 수 있다.

---

## 2021-02-12

### (HTTP) Request/Response vs Messaging

Request/Response 방식은 HTTP 프로토콜을 사용하기 때문에 Stateless한 특징이 있으며, 심플하고 
단순하기 때문에 구현하기 아주 쉽다. 하지만, 클라이언트-서버 사이에 강한 의존성이 생기며, 서버가 반드시
실행 중일 때만 데이터를 전달받을 수 있다. 그리고 클라이언트는 서버가 다음 메세지를 보내기 전까지 응답을 기다리고 있다.
<b>즉, 동기식 통신 방식</b>으로 동작한다.
<br>
장점
- 심플하고 구현하기 쉽다.
- Stateless

단점
- 클라이언트-서버 시스템 사이 높은 의존성
- 서버가 반드시 실행 중일 때 동작
- 동기식 통신 방식
<br>
<b>"HTTP Request/Response 통신은 단단하게 결합된 시스템 아키텍처이다"</b>

HTTP 통신과는 반대로, 느슨하게 결합 된 비동기 시스템 통합 방식 중 대표 기술은 바로 <b>"메시징"</b>이다.
"메시징"은 중간 시스템을 통해 발신자에서 수신자로 데이터를 전송하는 포괄적인 용어이다.
중간 시스템을 통해서 전송하기 때문에, 발신자(서버)는 데이터를 전송받는 수신자(클라이언트)에 대해서 전혀 알지 못한다.
메시지 채널만 알고 있으면 된다.
<br>
장점
- 클라이언트를 확장하기 쉽다
- MSA에 적합하다
- 느슨한 연결

단점
- 복잡도 증가
- 기술 스택 추가


## 2021-02-13

### Spring에서의 싱글톤 패턴

싱글톤 패턴은 1개의 클래스당 1개의 객체만을 생성하여 사용하는 디자인 패턴이다.
Spring에서는 스프링 컨테이너가 관리하는 객체인 Bean을 싱글톤패턴으로 구현하여 제공한다.
Java의 싱글톤은 해당 클래스로더 내에서 1개의 인스턴스만을 생성할 수 있지만, Spring에서는 스프링 
컨테이너의 컨텍스트에서 1개의 인스턴스를 생성할 수 있다. 그에 따라 Java의 싱글톤은 JVM의 라이프사이클에 의해
제어가 되지만, Spring의 싱글톤은 스프링 컨텍스트에 의해서 제어가 된다. 또한, Spring에서의 싱글톤은 Thread Safety를 
자동으로 보장하는 반면 Java로 구현한 싱글톤 패턴은 반드시 보장하지 못한다.
---
## 2021-02-15

### new String()과 ""의 차이

Java에서 문자열은 Heap 영역 내의 String Pool이라는 곳에서 따로 관리하게 된다. <b>""</b> 으로 선언된 String은 String Pool에 추가 되고
해당 값을 참조 값으로 가지게 된다.
<br>
반면, new String()으로 생성된 String은 String Pool이 아닌 Heap 영역에 새로운 객체를 등록하게 된다.

즉, 위 두 방법으로 객체를 생성하였을 경우 각 객체의 메모리상의 위치가 다르다.

### 선택정렬이란?

선택정렬은 <b>제자리 정렬 알고리즘</b> 하나이다.

- 제자리 정렬이란, 입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법이며,
해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘.

<img src="https://blog.kakaocdn.net/dn/bekAxf/btqBWrh1Sjl/AAVyKUtExiy6pdwfbhgR3k/img.gif" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbekAxf%2FbtqBWrh1Sjl%2FAAVyKUtExiy6pdwfbhgR3k%2Fimg.gif" data-origin-width="0" data-origin-height="0">
<blockquote>
      gif로 보는 선택정렬 [출처 : https://github.com/GimunLee]
</blockquote>

장점

- 알고리즘이 단순하고, 배열 안에서 교환하는 방식이므로 다른 메모리 공간을 필요로 하지 않는다.

단점

- 시간 복잡도가 O(n^2)로, 비효율적이다.
- 불안정 정렬이다.

---
## 2021-02-16

### INDEX란?

인덱스는 데이터 레코드를 빠르게 접근하기 위해서 <키, 포인터> 쌍으로 구성되는 데이터 구조이다.
테이블에 데이터가 저장되는데, 특정한 PK값을 가지는 데이터를 찾기 위해서 매번 접근하는 것은 비효율적이다.
따라서, PK 값과 해당하는 데이터 row의 주소를 자료구조로 묶어서 저장하는 것이 인덱스이다.

<br>
특징
- 인덱스는 데이터가 저장된 물리적 구조와 밀접한 관계가 있다.
- 인덱스는 레코드가 저장된 물리적 구조에 접근하는 방법을 제공.
- 인덱스를 통해서 파일의 레코드에 대해 엑세스를 빠르게 한다.
- 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 해야 효율적.
- 인덱스가 없으면 특정한 값을 찾기 위해서 테이블의 모든 데이터를 확인하는 Table Scan이 발생한다.
- 기본키를 위한 인덱스를 기본 인덱스, 기본 인덱스가 아닌 인덱스들을 보조 인덱스라고 한다. 대부분의 관계형 데이터 베이스 관리 시스템에서는 모든 기본 키에 데해서 자동적으로 기본 인덱스를 생성한다.


## 2021-02-17

### 클러스터형 인덱스, 넌 클러스트형 인덱스

<b>클러스터형 인덱스</b>
- 인덱스를 생성할 때는 데이터 페이지 전체를 다시 정렬한다.
- 대용량의 데이터를 강제로 다시 클러스터 인덱스를 생성하는건 조심.
- 인덱스 자체가 데이터 페이지이다. 인덱스 자체에 데이터가 포함.
- <b>비클러스터형 인덱스 보다 검색 속도는 더 빠르다, 하지만 데이터의 입력/수정/삭제는 느리다.</b>
- 테이블에 한 개만 생성할 수 있다.


<b>넌 클러스터형 인덱스</b>
- 별도의 페이지에 인덱스를 구성한다.
- 검색 속도는 느리지만, 데이터의 입력, 수정, 삭제가 더 빠르다.
- 남용할 경우에는 시스템 성능을 떨어뜨린는 결과를 가져온다.

---
## 2021-02-22

### SQL 실행순서, 쿼리 실행 과정.

<b> 1. 구문 분석.</b><br>
해당 쿼리가 문법적으로 틀리지 않는지 확인한다, 해당 구문을 SQL 서버가 이해할 수 있는 단위들로 분해하는 과정.<br>
<b> 2. 표준화</b><br>
실제로 필요 없는 부분들을 제거하고 표준화된 쿼리 트리가 만들어진다.<br>
<b> 3. 최적화</b><br>
통계나 조각 정보 등을 바탕으로 실행 계획을 만들어 낸다, 중요한 단계.
- 쿼리 분석 : 검색 제한자(SARG) 인지 조인 조건인지 판단.
- 인덱스 선택 : 인덱스 검색이나 테이블 스캔 중의 하나를 선택, 여러 인덱스 중 가장 효율적인 인덱스를 선택.
- 조인 처리 : JOIN, UNION, GROUP BY, ORDER BY 절 확인하고 적절한 작업 순서 선택. <br>
 
<b> 4. 컴파일</b><br>
컴파일을 하면 이진 코드가 생성된다. SQL Server에 메모리(프로시저 캐시)에 올린다.<br>
<b> 5. 실행</b><br>
엑세스 루틴으로 가서 실제 처리를 하고 결과를 돌려준다.

#### SELECET 실행 순서

문법 순서 : SELECT -> FROM -> WHERE -> GROUP BY -> HAVING -> ORDER BY<br>
실행 순서 : FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> OREDR BY<br>

<ol>
<li> 데이터 위치 (FROM) </li>
<li> 조건에 맞는 데이터 (WHERE) </li>
<li> 원하는 데이터로 가공 (GROUP BY) </li>
<li> 가공한 것 중에서 조건에 맞는 것 (HAVING) </li>
<li> 뽑아서 (SELECT) </li>
<li> 정렬(ORDER BY) </li>
</ol>

### JPA 영속성 컨텍스트

JDBC를 이용해서 애플리케이션을 개발 할 때 쿼리를 실행하면 DB로 쿼리를 바로 날린다.
하지만, 영속성 컨텍스트는 JDBC와 DB 사이에 위치하여 뭔가의 작업을 진행한다.
- 조회할 데이터가 영속성 컨텍스트에 존재하는지 확인
- 데이터가 없으면 쿼리를 생성
- 쿼리를 DB에 전송
- 결과 값을 영속성 컨텍스트가 전달 받음
- 전달 받은 데이터를 엔티티로 저장
- 엔티티 인스턴스를 리턴

장점?
<ol>
<li>특정 비즈니스에서 update, insert, delete 를 여러 번 구현했을 때 이전 방식에서는
코드가 수행될때마다 DB에 요청을 보내는 반면 영속성 컨텍스트는 쿼리를 생성하여
특정 영역에 저장만 해두었다가 flush가 되는 순간 한꺼번에 DB로 쿼리를 날린다. 이를 JPA에서는 <b>"쓰기 지연"</b>이라고 한다.</li>
<li>지연 로딩을 통해 특정 엔티티의 데이터를 사용하는 시점에 초기화하여 DB 요청을 보낼 수 있다.</li>
</ol>

영속성 컨텍스트는 트랜잭션이 종료되면 flush가 동작하게 된다.
즉, 트랜잭션과 영속성 컨텍스트는 동일한 라이프 사이클을 가지고 있다고 보면 된다.

### EntityManagerFactory?
엔티티 매니저 팩토리는 엔티티 매니저를 관리한다. 엔티티 매니저는 엔티티를 저장, 수정, 삭제, 조회하는 등 엔티티와
관련된 모든일을 한다.<br>
엔티티 매니저 팩토리는 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다.<br>
엔티티 매니저 팩포리는 여러 쓰레드가 동시에 접근해도 안전하므로 서로 다른 쓰레드 간에 공유해도 된다.
### EntityManager?
엔티티와 관련된 모든 일을 처리하기에 이름 그대로 엔티티를 관리하는 관리자이다.
엔티티 매니저를 이용하여 엔티티를 저장하게 되면 DB에 access하여 insert문을 전송한다.(중간 단계로 영속성 컨텍스트는 거치게 됨)
<br>
@PersistenceContext 애노테이션으로 주입받은 EntityManger는 Proxy로 감싸기 때문에 Thread-Safety를 보장한다.

---
## 2021-02-24

### String str = "Hello", String str = new String("Hello") 의 차이

전자의 경우에는 Hello를 Heap 메모리 String pool 에 저장하고 주소값을 str변수에 저장한다.
String str2 = "Hello" 를 추가할 경우 String pool에서 같은 문자열이 있는지 찾고 있으면 그 주소값을 마찬가지로 str2에 저장한다.
하지만, new String의 경우에는 계속 새로운 객체를 만들어 Heap에 저장하기 때문에 메모리를 낭비할 수 있다.
---
## 2021-02-25

### 프로세스, 스레드

기본적인 정의는 프로세스는 운영체제로부터 자원을 할당받은 작업의 단위이고 스레드는 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위이다.
쉽게 말해서 프로그램은 파일이 저장 장치에 저장되어 있지만 메모리에 올라가 있지 않는 정적인 상태이다.
프로그램을 실행하는 순간 컴퓨터 메모리에 올라가고 이 상태의 프로그램을 <b>프로세스</b>라고 한다.
스레드는 프로세스가 할당받은 메모리 영역 내에서 Stack 형식으로 따로 할당 받고, 나머지 Code, Data, Heap 형식으로 할당된 메모리 영역은 공유한다.
따라서, 각각의 스레드는 별도의 스택을 가지고 있지만 힙 메모리는 서로 읽고 쓸 수 있게 된다.
<br>
<ol>
멀티스레드의 장점
<li>컨텍스트 스위칭할 때 공유하고 있는 메모리만큼의 메모리 자원을 아낄 수 있다.</li>
<li>스레드는 프로세스 내의 스택 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적어서 응답 시간이 빠르다.</li>
</ol>

<ol>
멀티스레드의 단점
<li>스레드 하나가 프로세스 내 자원을 망쳐버리면 모든 프로세스가 종료될 수 있다.</li>
<li>자원을 공유하기 때문에 필연적으로 동기화 문제가 발생할 수 밖에 없다.</li>
</ol>
---
## 2021-02-26

### 웹 브라우저 구동 과정
<img src="https://t1.daumcdn.net/cfile/tistory/991691405C90E6851A"> 
##### 출처:http://tcpschool.com/webbasic/works
<br>
<ul>
<li>1,2 사용자가 웹 브라우저를 통해 찾고 싶은 웹 페이지의 URL주소를 입력한다</li>
<li>3 사용자가 입력한 URL 주소 중에서 도미엔 네임 부분을 DNS 서버에서 검색한다.</li>
<li>4 DNS 서버에서 해당 도메인 네임에 해당하는 IP주소를 찾아 사용자가 입력한 URL 정보와 함께 전달한다.</li>
<li>5,6 웹 페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성한다.
이렇게 생성된 HTTP 요청 메세지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 UP 주소의 컴퓨터로 전송된다. </li>
<li>7 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환한다. </li>
<li>8 웹 서버는 도착한 웹 페이지 URL 정보에 해당하는 데이터를 검색한다. </li>
<li>9,10 검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성한다. 
이렇게 생성된 HTTP 응답 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송한다. </li>
<li>11 도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환한다. </li>
<li>12 변환된 웹 페이지 데이터는 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다. </li>
</ul>



### String, Stringbuffer/StringBuilder
String str = "hello"; 에서 str += " world"; 를 하게 되면 문자열을 더해 변경된 것으로 착각했었다.
하지만 기존 "hello"에 "world"를 더해 새로운 메모리영역을 가리키게 변경되고, 처음 선언했던 "hello"의 경우에는
Garbage로 남았다가 GC에 의해 사라지게 된다. String 클래스는 불변하기 때문에 문자열을 수정하는 시점에 새로운 String 인스턴스가 생성되는 것이다. 
불변성을 가지기 때문에 문자열을 자주 읽어 들이는 경우에는 String을 사용해주면 좋지만, 문자열 추가, 수정, 삭제 등의 연산이 빈번하게 발생하는 경우에는
힙메모리에 많은 가비지가 생성되어 치명적인 영향을 끼치게 된다.
이를 해결하기 위해 가변성을 가지는 StringBuffer / StringBuilder 클래스를 도입하였다. 가변성의 특징을 가지기 때문에 append(), delete() 등을 이용하여
동일 객체 내에서 문자열을 변경하는 것이 가능하다.

#### StringBuffer vs StringBuilder
 둘의 큰 차이점은 동기화의 유무로써 StringBuffer는 동기화 키워드를 지원하여 멀티쓰레드 환경에서 안전하다.
참고로 String도 불변성을 가지기 때문에 멀티스레드 환경에서 안정성을 가지고 있다.

반대로 StringBuilder는 동기화를 지원하지 않기 때문에 단일스레드이거나 동기화를 고려하지 않아도 되는 경우 사용하는 것이 좋다.


### 스프링 설정 파일 보안 방법
